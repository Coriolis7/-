1.见识到了一种全新的游戏设计模式：游戏主体做成一个死循环，不停更新游戏数据，但是屏幕不是每次循环都刷新，而是以一个指定的刷新率进行刷新。但是当玩家进行了操作后，立即进行刷新，这样可以降低玩家的延迟感。

似乎游戏大多都是这种设计思路，因为游戏不是执行一遍就完了，而是玩家不退出就一直运行，因此要用一个死循环来运行游戏主体

2.对面向对象的理解更透彻了。以前不理解什么是面向对象，因为以前写的都是算法题，很少封装函数，就算封装了，往往也只会调用一两次，因此觉得封装似乎没什么必要，但在俄罗斯方块中，生成俄罗斯方块这个功能需要在后面反复调用，因此封装就很有必要了。

3.同时，也理解了私有成员和公共成员的必要性，有些东西封装好之后就是不需要调用了，也不能随便调用，否则会导致一些不可预料的后果，比如块的形状，一旦生成一个块，决定了它的形状，后面游戏运行中就不能再改了，否则一个方块玩着玩着形状还能变算怎么回事？

为了避免自己后面忘了这个不能改，或者别人用这个类时不知道这个不能改，干脆直接定成私有类，调用时不能改。如果一定要用这个成员，可以写一个接口，把这个成员复制一份传出去，相当于给了一个只读权限。

4.第一次用图形库，总的来讲还是挺好用的，只是使用过程中有点小问题。

第一个问题是显示图片的函数所有涉及大小的参数都没有指明单位，同时单位也不是像素，导致我直接按图片像素大小开窗口，开出来的窗口不能把图片显示全。这些函数中大小的单位应该是一个只有像素大小一半左右的单位。最后的解决办法是肉眼微调，找到合适的参数。

另一个问题是开始对于图片显示的逻辑没完全理解，这里的图片显示全都是直接贴图，后贴的图图层在上面，那么想要实现一个方块在背景上下落的效果，就需要先显示背景，再显示方块，再显示背景，挡住上一次的画面，在下面一格的位置再显示方块。也就是说想实现运动，需要用下一次的画面盖住上一次。

如果只在开始显示一次背景，后面方块每动一次显示一次方块，由于没有用背景盖住上一次的画面，方块的运动会表现出延时摄影的效果，每一帧的方块画面都会同时存在于屏幕上。

这个问题开始我还没意识到，开始只是跟着抄，视频里把背景每一帧显示一次，我也就这么写了。后来打注释的时候以为这个是多余的，就改成了只在初始化时显示一次背景，结果就出现了很恐怖的效果，后来思考了一下显示图片的机制才明白必须每一帧刷新一次背景。

5.对象运动的实现也很有意思。开始我试图独立写出这部分的逻辑，我的思路是先检测运动后有没有越界或者重叠，如果有就不运动了，但这个思路出现了一些莫名其妙地bug，比如到达边界就不动了，或者靠边界的一边总是会消失。

最终还是投降了，去看视频的实现，发现他使用了一种神奇的思路，先备份，再运动，然后检测运动后的状态是否合法（有没有出界或重叠），如果不合法，就用备份还原，如果合法就什么都不做。视频里旋转，下降，水平移动的逻辑都是这么实现的，我试了一下，这样写居然没有任何Bug！我也不知道为什么我的思路就不行，但是这种思路确实很优雅，不用对每种运动写不同的判定，而是统一写一个判断是否合法的函数，每次都先运动，然后调用这个函数检查运动后是否合法。

6.另一个有趣的思路是消行。消行就是要删去一行，然后把上面的方块都往下移动一格。朴素的思路当然是遍历每一行，如果这一行要消掉就把上面的所有方块往下复制，可以想象，如果有多行需要消掉，上面的方块实际上需要往下移动好几次，虽然还是O(kn)的，但是常数会很大。

视频里给出了一种永远是O(n)的，双指针的方法，很优雅。一个指针i是遍历所有行，另一个指针k负责复制，如果这一行不需要消掉，就把i所指的这一行复制到k所指的这一行的位置上，然后k后挪一位，如果这一行需要消掉，仍然把i所指的这一行复制到k所指的这一行的位置上，但是K指针不动，让下一次复制覆盖这一次，相当于就把这一行删掉了。

简言之，就是遍历一遍，选择性地复制，也可以实现删除一些行，并使数据仍然连续的效果。删掉一行，然后把后面所有行往前挪一位，是一种很丑陋的方法。

7.另外一个不算是收获的东西是被迫学会了c++的文件读写，因为c的文件读写fscanf被vs认定为不安全，最后把网上的方法使了个遍也没能绕过这个安全检测，于是被迫使用了c++的文件读写。

结果发现还挺简单的，继承了c++读写函数一贯的风格，重载了<<，输入输出直接用文件<< 变量就行。

8.最后的收获是vs写项目真好用，代码补全，自动生成方法定义，在面向对象开发中还是很好用的。